<?xml version="1.0" encoding="UTF-8"?>
<registry>
    <comment>
Copyright (c) 2015-2020 The Khronos Group Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

---- Exceptions to the Apache 2.0 License: ----

As an exception, if you use this Software to generate code and portions of
this Software are embedded into the generated code as a result, you may
redistribute such product without providing attribution as would otherwise
be required by Sections 4(a), 4(b) and 4(d) of the License.

In addition, if you combine or link code generated by this Software with
software that is licensed under the GPLv2 or the LGPL v2.0 or 2.1
("`Combined Software`") and if a court of competent jurisdiction determines
that the patent provision (Section 3), the indemnity provision (Section 9)
or other Section of the License conflicts with the conditions of the
applicable GPL or LGPL license, you may retroactively and prospectively
choose to deem waived or otherwise exclude such Section(s) of the License,
but only in their entirety and only with respect to the Combined Software.
    </comment>

    <comment>
This file, anari.xml, is the ANARI API Registry. It is a critically important
and normative part of the ANARI Specification, including a canonical
machine-readable definition of the API, parameter and member validation
language incorporated into the Specification and reference pages, and other
material which is registered by Khronos, such as tags used by extension and
layer authors. The authoritative public version of anari.xml is maintained in
the master branch of the Khronos ANARI GitHub project. The authoritative
private version is maintained in the master branch of the member gitlab
server.
    </comment>

    <tags comment="ANARI vendor/author tags for extensions and layers">
        <tag name="KHR"         author="Khronos"                       contact="Tom Olson @tomolson"/>
        <tag name="EXT"         author="Multivendor"                   contact="Jon Leech @oddhack"/>
    </tags>

    <types comment="ANARI type definitions">
        <type name="an_platform" category="include">#include "an_platform.h"</type>

            <comment>System header files that may be needed</comment>
        <type category="include" name="X11/Xlib.h"/>
            <comment>System types that may be needed</comment>
        <type requires="X11/Xlib.h" name="Display"/>

        <type category="define">#define <name>AN_MAKE_VERSION</name>(major, minor, patch) \
    (((major) &lt;&lt; 22) | ((minor) &lt;&lt; 12) | (patch))</type>
        <type category="define">#define <name>AN_VERSION_MAJOR</name>(version) ((uint32_t)(version) &gt;&gt; 22)</type>
        <type category="define">#define <name>AN_VERSION_MINOR</name>(version) (((uint32_t)(version) &gt;&gt; 12) &amp; 0x3ff)</type>
        <type category="define">#define <name>AN_VERSION_PATCH</name>(version) ((uint32_t)(version) &amp; 0xfff)</type>

        <type category="define">// ANARI 1.0 version number
#define <name>AN_API_VERSION_1_0</name> <type>AN_MAKE_VERSION</type>(1, 0, 0)// Patch version should always be set to 0</type>
        <type category="define">// Version of this file
#define <name>AN_HEADER_VERSION</name> 138</type>
        <type category="define" requires="AN_HEADER_VERSION">// Complete version of this file
#define <name>AN_HEADER_VERSION_COMPLETE</name> <type>AN_MAKE_VERSION</type>(1, 2, AN_HEADER_VERSION)</type>

            <comment>Aliases of builtin scalar types</comment>
        <type category="basetype">typedef <type>uint32_t</type> <name>AnFlags</name>;</type>
        <type category="basetype">typedef <type>uint32_t</type> <name>AnBool32</name>;</type>

            <comment>Basic C types, pulled in via an_platform.h</comment>
        <type requires="an_platform" name="void"/>
        <type requires="an_platform" name="char"/>
        <type requires="an_platform" name="float"/>
        <type requires="an_platform" name="double"/>
        <type requires="an_platform" name="uint8_t"/>
        <type requires="an_platform" name="uint16_t"/>
        <type requires="an_platform" name="uint32_t"/>
        <type requires="an_platform" name="uint64_t"/>
        <type requires="an_platform" name="int32_t"/>
        <type requires="an_platform" name="int64_t"/>
        <type requires="an_platform" name="size_t"/>
        <type requires="an_platform" name="int"/>

                <comment>Abstract handles referring to API objects</comment>
        <type category="handle">typedef <type>void</type> *<name>AnDevice</name>;</type>
        <type category="handle">typedef <type>void</type> <name>_AnManagedObject</name>;</type>
        <type category="handle">typedef <type>_AnManagedObject</type>* <name>AnObject</name>;</type>

            <comment>Types generated from corresponding enums tags below</comment>
        <type name="AnError" category="enum"/>
        <type name="AnDeviceProperty" category="enum"/>

        <comment>Callback functions pointer types</comment>
        <type category="funcpointer">typedef void (ANAPI_PTR *<name>AnStatusFunc</name>)(
    const <type>char</type>*                                 messageText);</type>

            <comment>Struct types</comment>
        <type category="struct" name="AnBounds">
            <member><type>float</type> <name>lower</name>[3]</member>
            <member><type>float</type> <name>upper</name>[3]</member>
        </type>
     </types>

    <comment>ANARI enumerant (token) definitions</comment>

    <enums name="API Constants" comment="ANARI hardcoded constants - not an enumerated type, part of the header boilerplate">
        <enum value="1"     name="AN_TRUE"/>
        <enum value="0"     name="AN_FALSE"/>
    </enums>

    <comment>
        Most tokens in ANARI are actual typed enumerants in
        their own numeric namespaces. The "name" attribute is the C enum
        type name, and is pulled in from a type tag definition above
        (slightly clunky, but retains the type / enum distinction). "type"
        attributes of "enum" or "bitmask" indicate that these values should
        be generated inside an appropriate definition.
    </comment>

    <enums name="AnError" type="enum">
        <enum value="0"     name="AN_NO_ERROR"/>
        <enum value="1"     name="AN_UNKNOWN_ERROR"/>
        <enum value="2"     name="AN_INVALID_ARGUMENT"/>
        <enum value="3"     name="AN_INVALID_OPERATION"/>
        <enum value="4"     name="AN_OUT_OF_MEMORY"/>
        <enum value="5"     name="AN_UNSUPPORTED_CPU"/>
        <enum value="6"     name="AN_VERSION_MISMATCH"/>
    </enums>
    <enums name="AnDeviceProperty" type="enum">
        <enum value="0"     name="AN_DEVICE_VERSION"/>
        <enum value="1"     name="AN_DEVICE_VERSION_MAJOR"/>
        <enum value="2"     name="AN_DEVICE_VERSION_MINOR"/>
        <enum value="3"     name="AN_DEVICE_VERSION_PATCH"/>
        <enum value="4"     name="AN_DEVICE_SO_VERSION"/>
    </enums>

    <commands comment="ANARI command definitions">
        <command>
            <proto><type>AnError</type> <name>anInit</name></proto>
            <param><type>int</type>* <name>argc</name></param>
            <param>const <type>char</type>** <name>argv</name></param>
        </command>
        <command>
            <proto><type>int64_t</type> <name>anDeviceGetProperty</name></proto>
            <param><type>AnDevice</type> <name>device</name></param>
            <param><type>AnDeviceProperty</type> <name>property</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>anShutdown</name></proto>
        </command>
        <command>
            <proto><type>AnDevice</type> <name>anNewDevice</name></proto>
            <param>const <type>char</type>* <name>deviceType</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>anSetCurrentDevice</name></proto>
            <param><type>AnDevice</type> <name>device</name></param>
        </command>
        <command>
            <proto><type>void</type> <name>anDeviceSetStatusFunc</name></proto>
            <param><type>AnDevice</type> <name>device</name></param>
            <param><type>AnStatusFunc</type> <name>callback</name></param>
        </command>
        <command>
            <proto><type>AnBounds</type> <name>anGetBounds</name></proto>
            <param><type>AnObject</type> <name>object</name></param>
        </command>
    </commands>

    <feature api="anari" name="AN_VERSION_1_0" number="1.0" comment="ANARI core API interface definitions">
        <require comment="Header boilerplate">
            <type name="an_platform"/>
        </require>
        <require comment="API version">
            <type name="AN_API_VERSION_1_0"/>
            <type name="AN_VERSION_MAJOR"/>
            <type name="AN_VERSION_MINOR"/>
            <type name="AN_VERSION_PATCH"/>
            <type name="AN_HEADER_VERSION"/>
            <type name="AN_HEADER_VERSION_COMPLETE"/>
        </require>
        <require comment="API constants">
            <enum name="AN_TRUE"/>
            <enum name="AN_FALSE"/>
        </require>
        <require comment="Types">
            <type name="AnBool32"/>
            <type name="AnDevice"/>
            <type name="AnDeviceProperty"/>
        </require>
        <require comment="Commands">
            <command name="anInit"/>
            <command name="anDeviceGetProperty"/>
            <command name="anShutdown"/>
            <command name="anNewDevice"/>
            <command name="anSetCurrentDevice"/>
            <command name="anDeviceSetStatusFunc"/>
            <command name="anGetBounds"/>
            <command name="anDeviceSetStatusFunc"/>
        </require>
    </feature>

    <extensions comment="ANARI extension interface definitions">
    </extensions>
</registry>
